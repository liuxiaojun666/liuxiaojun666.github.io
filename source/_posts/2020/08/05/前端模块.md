---
title: 前端模块
date: 2020-08-05 22:06:37
tags:
---

#### ES6 模块

- ES6 模块强制自动采用严格模式
- 对应 script 标签中将属性 type 值设置为“module”才能被正确地解析为 ES6 模块
- 在 Node.js 下使用 ES6 模块则需要将文件名后缀改为“.mjs”，用来和 Node.js 默认使用的 CommonJS 规范模块作区分。


特性**值引用**
``` js
// a.js
export var a = '';
setTimeout(() => a = 'a', 500);
// b.js
import { a } from './a.js'
console.log(a) // ''
setTimeout(() => console.log(a), 1000) // 'a'
```
特性**静态声明**
``` js
// 必须首部声明
leta a = 1
import { app } from './app';
// 不允许使用变量或表达式
import { 'a' + 'p' + 'p' } from './app';
// 不允许被嵌入语句逻辑
if (moduleName === 'app') {
  import { init } from './app';
} else {
  import { init } from './bpp';
}
```

##### import 的动态模块提案
``` js
import(`./section-modules/${link.dataset.entryModule}.js`)
.then(module => {
  module.loadPageInto(main);
})
.catch(err => {
  main.textContent = err.message;
});
```
- 违反首部声明要求，那么就意味着可以在代码运行时按需加载模块，这个特性就可以用于首屏优化，根据路由和组件只加载依赖的模块。
- 违反变量或表达式要求，则意味着可以根据参数动态加载模块。
- 违反嵌入语句逻辑规则，可想象空间更大，比如可以通过 Promise.race 方式同时加载多个模块，选择加载速度最优模块来使用，从而提升性能。

#### CommonJS

CommonJS 规定每个文件就是一个模块，有独立的作用域。每个模块内部，都有一个 module 对象，代表当前模块。通过它来导出 API，它有以下属性：

- id 模块的识别符，通常是带有绝对路径的模块文件名；
- filename 模块的文件名，带有绝对路径；
- loaded 返回一个布尔值，表示模块是否已经完成加载；
- parent 返回一个对象，表示调用该模块的模块；
- children 返回一个数组，表示该模块要用到的其他模块；
- exports 表示模块对外输出的值。

引用模块则需要通过 require 函数，它的基本功能是，读入并执行一个 JavaScript 文件，然后返回该模块的 exports 对象。

特性**值拷贝**
``` js
// a.js
var a = '';
setTimeout(() => a = 'a', 500);
module.exports = a
// b.js
// 特性 动态声明
var a = require('./a.js')
console.log(a) // ''
setTimeout(() => console.log(a), 1000) // ''
```

#### AMD
``` js
 define("alpha", ["require", "exports", "beta"], function (require, exports, beta) {
     exports.verb = function() {
         return beta.verb();
     }
 });
```
- 第 1 个参数 id 为模块的名称，该参数是可选的。如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字；如果提供了该参数，模块名必须是“顶级”的和绝对的（不允许相对名字）。
- 第 2 个参数 dependencies 是个数组，它定义了所依赖的模块。依赖模块必须根据模块的工厂函数优先级执行，并且执行的结果应该按照依赖数组中的位置顺序以参数的形式传入（定义中模块的）工厂函数中。
- 第 3 个参数 factory 为模块初始化要执行的函数或对象。如果是函数，那么该函数是单例模式，只会被执行一次；如果是对象，此对象应该为模块的输出值。

特性**异步加载**

#### CMD
CMD 定义模块也是通过一个全局函数 define 来实现的，但只有一个参数，该参数既可以是函数也可以是对象：

如果这个参数是对象，那么模块导出的就是对象；如果这个参数为函数，那么这个函数会被传入 3 个参数 require 、 exports 和 module。
``` js
define(function(require, exports, module) {
  var add = require('math').add;
  exports.increment = function(val) {
    return add(val, 1);
  };
  module.id = "increment";
});
```

第 1 个参数 require 是一个函数，通过调用它可以引用其他模块，也可以调用 require.async 函数来异步调用模块。

第 2 个参数 exports 是一个对象，当定义模块的时候，需要通过向参数 exports 添加属性来导出模块 API。

第 3 个参数 module 是一个对象，它包含 3 个属性：

- uri，模块完整的 URI 路径；
- dependencies，模块的依赖；
- exports，模块需要被导出的 API，作用同第二个参数 exports。

特性 **懒加载**
**整合了 CommonJS 和 AMD 规范的特点**

#### UMD
UMD（Universal Module Definition，统一模块定义）其实并不是模块管理规范，而是带有前后端同构思想的模块封装工具。通过 UMD 可以在合适的环境选择对应的模块规范。比如在 Node.js 环境中采用 CommonJS 模块管理，在浏览器端且支持 AMD 的情况下采用 AMD 模块，否则导出为全局函数。

``` js
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    define([], factory);
  } else if (typeof exports === 'object') {
module.exports,
    module.exports = factory();
  } else {
    root.returnExports = factory();
  }
}(this, function () {
  //。。。
  return {};
}));
```

#### ES5 标准下如何编写模块

``` js
var mod = (function(w){
  function f() {
    ...
  }
  var a = ''
  ... 
  return {
  　　f,
  　　a
  };
})(window);
```

#### webpack 打包原理
``` js
// index.js
import { text, write } from './m'
write(`<h1>${text} ${text2}</h1>`)
// m.js
const write = content => document.write(content)
var text = 'hello'
export { text, write }
```

``` js
// bundle.js
(function(modules) {
  ...
})({
  "./index.js": (function(module, __webpack_exports__, __webpack_require__) {
    ...
  },
  "./m.js": (function(module, __webpack_exports__, __webpack_require__) {
    ...
  }
})
```
这个立即执行函数会加载一个初始模块，也就是 webpack 配置的 entry 模块，按照依赖关系调用模块对应的函数并缓存。
``` js
function (modules) { 
  var installedModules = {};
  function __webpack_require__(moduleId) {
    if (installedModules[moduleId]) {
      return installedModules[moduleId].exports;
    }
    var module = installedModules[moduleId] = {
      i: moduleId,
      l: false,
      exports: {}
    };
    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    module.l = true;
    return module.exports;
  }
  ...
  return __webpack_require__(__webpack_require__.s = "./index.js");
}
```
每个模块定义函数都会传入 3 个参数，其中参数 module 可以理解为当前模块的配置参数，包含模块 id 等信息。参数 webpack_exports 是一个对象，模块需要导出的 API 都可以添加到这个对象上；参数 webpack_require 是一个函数，负责引用依赖的模块。

``` js
// index.js 中引入 m.js 模块
var _m__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./m */ "./m.js");
// m.js 中导出字符串 text 和函数 write
__webpack_require__.d(__webpack_exports__, "text", function () {
  return text;
});
__webpack_require__.d(__webpack_exports__, "write", function () {
  return write;
});
const write = content => document.write(content)
var text = 'hello'
```



